---
import { X } from "@lucide/astro";

const scenarios = [
  "O Lighthouse dá nota boa, mas a navegação é confusa",
  "O código segue a WCAG, mas ninguém testou com teclado",
  "Acessibilidade vira uma tarefa no final do sprint",
  "Ferramentas dizem que está tudo certo, mas os usuários dizem o contrário",
];
---

<section class="px-6 py-6 lg:py-12 bg-card" aria-labelledby="community-problem">
  <div class="max-w-4xl mx-auto">
    <h2
      id="community-problem"
      class="text-2xl md:text-4xl font-bold text-center mb-3"
    >
      O problema
    </h2>
    <p class="text-lg text-muted-foreground text-center mb-6 max-w-2xl mx-auto">
      Se você trabalha com front-end, QA ou web em geral, provavelmente já viveu
      pelo menos um desses cenários:
    </p>

    <ul class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-12">
      {
        scenarios.map((scenario) => (
          <li class="flex items-center gap-4 p-5 rounded-lg bg-card border border-border">
            <div class="w-12 h-12 rounded-lg bg-primary/10 flex items-center justify-center shrink-0">
              <X class="w-6 h-6 text-white shrink-0 mt-0.5" />
            </div>
            <p class="text-white">{scenario}</p>
          </li>
        ))
      }
    </ul>
    <p class="text-lg text-center text-muted-foreground">
      Isso acontece porque acessibilidade foi reduzida a checklist, quando na
      prática ela depende de <strong class="text-foreground"
        >decisões técnicas bem feitas desde o início</strong
      >.
    </p>
  </div>
</section>
